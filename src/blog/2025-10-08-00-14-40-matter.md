---
title: Defining Your First Schema
date: '2025-10-08T00:15:00+06:00'
image: /src/assets/blog/debit-credit-analysis1.webp
tags:
  - post
  - featured
___mb_schema: /.mattrbld/schemas/article.json
---
With the initial setup out of the way, it’s finally time to think about what information our blog posts should include. It could be anything, really, but for our simple example the following details should be enough:

-   A title
    
-   A hero image
    
-   A set of tags
    
-   An author
    
-   A publishing date
    
-   The content of the post (duh!)
    

This list is basically a *schema* that every blog post will stick to. On our website, we can use these details to display the post itself, obviously, but also for sorting all posts by publishing date or author, for example, or have our SSG automatically generate a page for each tag that contains all posts that have said tag—Mattrbld doesn’t care, it just needs to know what data content editors need to input to create a valid blog post.

### **Schema Creation**

The **Schemas** tab is the right place to turn the above list into a proper Schema. Simply click the “Add” button and give the Schema a name, “Blog Post” seems fitting, but you could call it anything you want. Mattrbld automatically makes sure that only safe characters are used in filenames, hence why the file might not be created with *exactly* the same name you typed.

### **Schema Editing**

Once you’ve created the Schema, you’ll be taken to the Schema Editor, a visual drag-and-drop editor that allows you to intuitively translate the list above into a proper Schema. To do so click “Add Field” and you’ll be presented with an extensive list of built-in fields.

Each of these fields has a different function and presents content editors with a different input field once they create and edit actual content. For this guide we’ll only be looking at five of these fields:

-   Unformatted Text (for the title and author of the post)
    
-   Rich Text (for the content)
    
-   Date (for the publishing date)
    
-   Image (for the hero image)
    
-   Tags (for the tags)
    

Try adding a Unformatted Text field by either dragging it into the dropzone on the left, or clicking the “plus”-icon next to it.

**Congratulations!** You’ve just added your first field. If you now click on it, you’ll see all of its options. Each field has a set of options common to every field (like `label` and `key`, validation and visibility options, etc.) and some that are unique to that type of field.

#### Basic Configuration

Let’s turn our Unformatted Text field into the title field for our Schema by changing its label to “Post Title” and the key to “title”. As you might’ve guessed, the label is the actual label that will be displayed above the field when creating or editing a blog post. The key, however, is what the field will be saved under in the actual blog post file.

This separation allows you to define descriptive labels for content editors, while keeping things clean and concise in the data structure (or conforming to conventions / requirements imposed by the program consuming the content, for example your SSG).

Unformatted Text fields are pretty simple fields, the only options unique to them are the wrapping and line-break options. Since the titles of our blog posts won’t need to have multiple lines, you can leave the “Allow line breaks” option off. The titles are probably also not going to be very long, so we could also disable the “Wrap the text if it’s wider than the input field” option, but considering Mattrbld also works on mobile phones, the input field could end up being quite narrow, so it would be beneficial to content editors if this option was left on and the could see everything without having to scroll within the input field.

#### Adding Validation

What we do want, however, is to mark the title field as required, since every blog post should have a title. To do so, simply toggle on the “Make this field required” option in the “Validation” section. Here we could also specify some more granular requirements like minimum and maximum length, but they won’t be necessary in this case.

#### Rinse and Repeat

Adding the other fields works exactly the same way, just click “Add field” and add and configure the remaining fields:

-   Image (label: Hero Image, key: hero)
    
-   Unformatted Text (label: Author Name, key: author)
    
-   Date (label: Published at, key: date)
    
-   Tags (label: Tags, key: tags)
    
-   Rich Text (label: Post Content, key: **content**, Output format: **Markdown**)
    

While the keys of the other fields don’t matter much in this specific example, the Rich Text field *must* have the key **content**. This is because we want to save our blog posts as Markdown files with a frontmatter—a common format for many SSGs.

So Mattrbld knows which of the fields in a Schema holds the information that is supposed to be added after the frontmatter, i.e. as the body of the Markdown file, we need to give one of our fields the key “content”.

While configuring the Rich Text field, you might also have noticed that it allows for some quite extensive customisation options. This is so designers and developers can closely control what type of text formatting can be used in these very versatile rich text fields. For this example, the defaults should suffice, except for the fact that we obviously want the output to be **Markdown** instead of plain HTML.

#### Saving the Changes

Once you have everything set up, click the “Save” button in the top right to save your changes and then close the Schema Editor by either clicking the back-arrow on the top left, or using your browser’s back button.

You will return to the “Schemas” tab in the project settings and see your brand new “Blog Post” schema displayed in the list with a small orange dot next to the name. This dot shows that the file has local changes that have not yet been pushed back to the central Git-repository—something we’ll deal with once everything has been set up.

**Quick recap**: so far, we have come up with a set of properties we want all Blog Posts to have and then proceeded to turn that list into a Schema with the appropriate types for each property by using Mattrbld’s predefined fields.
